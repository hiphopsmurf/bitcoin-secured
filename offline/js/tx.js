// Generated by CoffeeScript 1.5.0
(function() {
  var bignum2btcstr, btcstr2bignum, dumpScript, endian, errv, isEmpty, parseScript, priv2key, readBuffer, readString, readVarInt, root, tx_parseBCI, u16, u32, u64, u8, uint;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.TX = (function() {

    function TX(eckey) {
      this.inputs = [];
      this.eckey = eckey;
      this.balance = 0;
    }

    TX.prototype.getBalance = function() {
      return this.balance;
    };

    TX.prototype.getAddress = function() {
      return this.eckey.getBitcoinAddress().toString();
    };

    TX.prototype.parseInputs = function(text, address) {
      var res;
      res = tx_parseBCI(text, address);
      this.balance = res.balance;
      return this.inputs = res.unspenttxs;
    };

    TX.prototype.construct = function(address, changeAddress, sendValue, feeValue) {
      var availableValue, b64hash, changeValue, connectedScript, hash, hashType, i, index, pubKey, pubKeyHash, script, selectedOuts, sendTx, signature, txValue, txin;
      sendValue = btcstr2bignum(sendValue);
      feeValue = btcstr2bignum(feeValue);
      selectedOuts = [];
      txValue = sendValue.add(feeValue);
      availableValue = BigInteger.ZERO;
      for (hash in this.inputs) {
        if (!this.inputs.hasOwnProperty(hash)) {
          continue;
        }
        for (index in this.inputs[hash]) {
          if (!this.inputs[hash].hasOwnProperty(index)) {
            continue;
          }
          script = parseScript(this.inputs[hash][index].script);
          b64hash = Crypto.util.bytesToBase64(Crypto.util.hexToBytes(hash));
          txin = new Bitcoin.TransactionIn({
            outpoint: {
              hash: b64hash,
              index: index
            },
            script: script,
            sequence: 4294967295
          });
          selectedOuts.push(txin);
          availableValue = availableValue.add(new BigInteger("" + this.inputs[hash][index].amount, 10));
          if (availableValue.compareTo(txValue) >= 0) {
            break;
          }
        }
      }
      if (availableValue.compareTo(txValue) < 0) {
        throw new Error("Insufficient funds.");
      }
      changeValue = availableValue.subtract(txValue);
      sendTx = new Bitcoin.Transaction();
      i = 0;
      while (i < selectedOuts.length) {
        sendTx.addInput(selectedOuts[i]);
        i++;
      }
      sendTx.addOutput(new Bitcoin.Address(address), sendValue);
      if (changeValue.compareTo(BigInteger.ZERO) > 0) {
        sendTx.addOutput(new Bitcoin.Address(changeAddress), changeValue);
      }
      hashType = 1;
      i = 0;
      while (i < sendTx.ins.length) {
        connectedScript = selectedOuts[i].script;
        hash = sendTx.hashTransactionForSignature(connectedScript, i, hashType);
        pubKeyHash = connectedScript.simpleOutPubKeyHash();
        signature = this.eckey.sign(hash);
        signature.push(parseInt(hashType, 10));
        pubKey = this.eckey.getPub();
        script = new Bitcoin.Script();
        script.writeBytes(signature);
        script.writeBytes(pubKey);
        sendTx.ins[i].script = script;
        i++;
      }
      return sendTx;
    };

    TX.prototype.deserialize = function(bytes) {
      var f, i, lock_time, n, op, script, sendTx, seq, tx_ver, txin, txout, value, vin_sz, vout_sz;
      sendTx = new Bitcoin.Transaction();
      f = bytes.slice(0);
      tx_ver = u32(f);
      vin_sz = readVarInt(f);
      if (errv(vin_sz)) {
        return null;
      }
      i = 0;
      while (i < vin_sz) {
        op = readBuffer(f, 32);
        n = u32(f);
        script = readString(f);
        seq = u32(f);
        txin = new Bitcoin.TransactionIn({
          outpoint: {
            hash: Crypto.util.bytesToBase64(op),
            index: n
          },
          script: new Bitcoin.Script(script),
          sequence: seq
        });
        sendTx.addInput(txin);
        i++;
      }
      vout_sz = readVarInt(f);
      if (errv(vout_sz)) {
        return null;
      }
      i = 0;
      while (i < vout_sz) {
        value = u64(f);
        script = readString(f);
        txout = new Bitcoin.TransactionOut({
          value: value,
          script: new Bitcoin.Script(script)
        });
        sendTx.addOutput(txout);
        i++;
      }
      lock_time = u32(f);
      sendTx.lock_time = lock_time;
      return sendTx;
    };

    return TX;

  })();

  isEmpty = function(ob) {
    var i;
    for (i in ob) {
      if (ob.hasOwnProperty(i)) {
        return false;
      }
    }
    return true;
  };

  bignum2btcstr = function(satoshi) {
    var i, s;
    s = String(satoshi);
    if (satoshi >= 100000000) {
      i = s.length - 8;
      return s.substr(0, i) + "." + s.substr(i);
    } else {
      i = 8 - s.length;
      return "0." + Array(i + 1).join("0") + s;
    }
  };

  btcstr2bignum = function(btc) {
    var diff, i, mul, value;
    i = btc.indexOf(".");
    value = new BigInteger(btc.replace(/\./, ""));
    diff = 9 - (btc.length - i);
    if (i === -1) {
      mul = "100000000";
    } else if (diff < 0) {
      return value.divide(new BigInteger(Math.pow(10, -1 * diff).toString()));
    } else {
      mul = Math.pow(10, diff).toString();
    }
    return value.multiply(new BigInteger(mul));
  };

  priv2key = function(privBase58) {
    var bytes, checksum, hash, key, version;
    bytes = Bitcoin.Base58.decode(privBase58);
    hash = bytes.slice(0, 33);
    checksum = Crypto.SHA256(Crypto.SHA256(hash, {
      asBytes: true
    }), {
      asBytes: true
    });
    if (checksum[0] !== bytes[33] || checksum[1] !== bytes[34] || checksum[2] !== bytes[35] || checksum[3] !== bytes[36]) {
      throw "Checksum validation failed!";
    }
    version = hash.shift();
    if (version !== 0x80) {
      throw "Version " + version + " not supported!";
    }
    key = new Bitcoin.ECKey(hash);
    return key;
  };

  uint = function(f, size) {
    var b, bytes, i, n, pos;
    if (f.length < size) {
      return 0;
    }
    bytes = f.slice(0, size);
    pos = 1;
    n = 0;
    i = 0;
    while (i < size) {
      b = f.shift();
      n += b * pos;
      pos *= 256;
      i++;
    }
    if (size <= 4) {
      return n;
    } else {
      return bytes;
    }
  };

  u8 = function(f) {
    return uint(f, 1);
  };

  u16 = function(f) {
    return uint(f, 2);
  };

  u32 = function(f) {
    return uint(f, 4);
  };

  u64 = function(f) {
    return uint(f, 8);
  };

  errv = function(val) {
    return val instanceof BigInteger || val > 0xffff;
  };

  readBuffer = function(f, size) {
    var i, res;
    res = f.slice(0, size);
    i = 0;
    while (i < size) {
      f.shift();
      i++;
    }
    return res;
  };

  readString = function(f) {
    var len;
    len = readVarInt(f);
    if (errv(len)) {
      return [];
    }
    return readBuffer(f, len);
  };

  readVarInt = function(f) {
    var t;
    t = u8(f);
    if (t === 0xfd) {
      return u16(f);
    } else if (t === 0xfe) {
      return u32(f);
    } else if (t === 0xff) {
      return u64(f);
    } else {
      return t;
    }
  };

  dumpScript = function(script) {
    var chunk, i, op, out;
    out = [];
    i = 0;
    while (i < script.chunks.length) {
      chunk = script.chunks[i];
      op = new Bitcoin.Opcode(chunk);
      if (typeof chunk === "number") {
        out.push(op.toString());
      } else {
        out.push(Crypto.util.bytesToHex(chunk));
      }
      i++;
    }
    return out.join(" ");
  };

  tx_parseBCI = function(data, address) {
    var balance, i, lilendHash, o, r, script, txs, unspenttxs, value;
    r = data;
    txs = r.unspent_outputs;
    if (!txs) {
      throw "Not a BCI format";
    }
    delete unspenttxs;
    unspenttxs = {};
    balance = BigInteger.ZERO;
    for (i in txs) {
      o = txs[i];
      lilendHash = o.tx_hash;
      script = dumpScript(new Bitcoin.Script(Crypto.util.hexToBytes(o.script)));
      value = new BigInteger("" + o.value, 10);
      if (!(lilendHash in unspenttxs)) {
        unspenttxs[lilendHash] = {};
      }
      unspenttxs[lilendHash][o.tx_output_n] = {
        amount: value,
        script: script
      };
      balance = balance.add(value);
    }
    return {
      balance: balance,
      unspenttxs: unspenttxs
    };
  };

  isEmpty = function(ob) {
    var i;
    for (i in ob) {
      if (ob.hasOwnProperty(i)) {
        return false;
      }
    }
    return true;
  };

  endian = function(string) {
    var i, out;
    out = [];
    i = string.length;
    while (i > 0) {
      out.push(string.substring(i - 2, i));
      i -= 2;
    }
    return out.join("");
  };

  btcstr2bignum = function(btc) {
    var diff, i, mul, value;
    i = btc.indexOf(".");
    value = new BigInteger(btc.replace(/\./, ""));
    diff = 9 - (btc.length - i);
    if (i === -1) {
      mul = "100000000";
    } else if (diff < 0) {
      return value.divide(new BigInteger(Math.pow(10, -1 * diff).toString()));
    } else {
      mul = Math.pow(10, diff).toString();
    }
    return value.multiply(new BigInteger(mul));
  };

  parseScript = function(script) {
    var i, newScript, s;
    newScript = new Bitcoin.Script();
    s = script.split(" ");
    for (i in s) {
      if (Bitcoin.Opcode.map.hasOwnProperty(s[i])) {
        newScript.writeOp(Bitcoin.Opcode.map[s[i]]);
      } else {
        newScript.writeBytes(Crypto.util.hexToBytes(s[i]));
      }
    }
    return newScript;
  };

}).call(this);
